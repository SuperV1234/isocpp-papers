<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>allocate_unique and related utilities</title>
<meta name="date" content="2016-04-04" />
<meta name="author" content="Miro Knejp &lt;miro.knejp&#64;gmail.com&gt;" />
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="allocate-unique-and-related-utilities">
<h1 class="title">allocate_unique and related utilities</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">Document:</th><td class="field-body">Dxxxx</td>
</tr>
<tr><th class="docinfo-name">Date:</th>
<td>2016-04-04</td></tr>
<tr class="field"><th class="docinfo-name">Project:</th><td class="field-body">Programming Language C++</td>
</tr>
<tr class="field"><th class="docinfo-name">Audience:</th><td class="field-body">Library Evolution Working Group</td>
</tr>
<tr><th class="docinfo-name">Author:</th>
<td>Miro Knejp &lt;<a class="reference external" href="mailto:miro.knejp&#64;gmail.com">miro.knejp&#64;gmail.com</a>&gt;</td></tr>
<tr class="field"><th class="docinfo-name">URL:</th><td class="field-body"><a class="reference external" href="https://github.com/mknejp/isocpp-papers/blob/master/dxxxx-allocate_unique.rst">https://github.com/mknejp/isocpp-papers/blob/master/dxxxx-allocate_unique.rst</a></td>
</tr>
</tbody>
</table>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id1">Abstract</a></h1>
<p>This paper proposes the addition of the function <tt class="docutils literal">allocate_unique()</tt> to complement the functionality of <tt class="docutils literal">allocate_shared()</tt> for <tt class="docutils literal">unique_ptr</tt>, as well as the addition of the utilities <tt class="docutils literal">allocator_delete</tt> and <tt class="docutils literal">make_allocator_delete()</tt> to hide frequently needed boilerplate when implementing allocator-aware data structures.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id2">Motivation</a></li>
<li><a class="reference internal" href="#proposal" id="id3">Proposal</a><ul>
<li><a class="reference internal" href="#synopsis" id="id4">Synopsis</a></li>
<li><a class="reference internal" href="#allocator-delete" id="id5">allocator_delete</a></li>
<li><a class="reference internal" href="#make-allocator-delete" id="id6">make_allocator_delete</a></li>
<li><a class="reference internal" href="#allocate-unique" id="id7">allocate_unique</a></li>
</ul>
</li>
<li><a class="reference internal" href="#applications-outside-of-allocate-shared" id="id8">Applications Outside of allocate_shared</a><ul>
<li><a class="reference internal" href="#node-based-containers" id="id9">Node-Based Containers</a></li>
<li><a class="reference internal" href="#type-erasure" id="id10">Type Erasure</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues" id="id11">Open Issues</a><ul>
<li><a class="reference internal" href="#allocate-unique-t" id="id12">allocate_unique&lt;T[]&gt;</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary" id="id13">Summary</a></li>
<li><a class="reference internal" href="#technical-specification" id="id14">Technical Specification</a></li>
<li><a class="reference internal" href="#references" id="id15">References</a></li>
</ul>
</div>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id2">Motivation</a></h1>
<p>There is currently an asymmetry in functionality regarding the creation of <tt class="docutils literal">shared_ptr</tt> and <tt class="docutils literal">unique_ptr</tt>. Both of them can be conviently created with <tt class="docutils literal">make_shared()</tt> and <tt class="docutils literal">make_unique()</tt>, respectively, using the default allocator. However if one wishes to use a custom allocator only the former provides a convenient factory in the form of <tt class="docutils literal">allocate_shared()</tt> whereas there is no such facility for <tt class="docutils literal">unique_ptr</tt> and one has to write quite an amount of non-trivial code to create one's own.</p>
<p>The additions proposed in this paper can be found re-intenved in virtually every library that offers custom allocator support and are already present in standard library implementations for internal use making it obvious this is a frequently sought after functionality that should be readily available in the standard (and <em>de-facto</em> already is, albeit not under a well-known name).</p>
<p>The inclusion of <tt class="docutils literal">allocator_delete</tt> and <tt class="docutils literal">make_allocator_delete()</tt> removes an additional burden for implementing allocator-aware data structures outside the scope of <tt class="docutils literal">unique_ptr</tt>. Together with <tt class="docutils literal">allocate_unique</tt> they provide the means to conveniently create and destroy objects with custom allocators which are not directly tied to <tt class="docutils literal">unique_ptr</tt> lifetimes (such as node-based or type-erasing containers, to name a few).</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id3">Proposal</a></h1>
<div class="section" id="synopsis">
<h2><a class="toc-backref" href="#id4">Synopsis</a></h2>
<pre class="code c++ literal-block">
<span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">class</span> <span class="name class">T</span><span class="punctuation">,</span> <span class="keyword">class</span> <span class="name class">Alloc</span><span class="operator">&gt;</span>
<span class="keyword">class</span> <span class="name class">allocator_delete</span> <span class="punctuation">{</span>
<span class="keyword">public</span><span class="operator">:</span>
  <span class="keyword">using</span> <span class="name">allocator_type</span> <span class="operator">=</span> <span class="name">remove_cv_t</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="operator">&gt;</span><span class="punctuation">;</span>
  <span class="keyword">using</span> <span class="name">pointer</span> <span class="operator">=</span> <span class="keyword">typename</span> <span class="name">allocator_traits</span><span class="operator">&lt;</span><span class="name">allocator_type</span><span class="operator">&gt;::</span><span class="name">pointer</span><span class="punctuation">;</span>

  <span class="keyword">template</span><span class="operator">&lt;</span><span class="name">class</span><span class="punctuation">...</span> <span class="name">Args</span><span class="operator">&gt;</span>
  <span class="name">allocator_delete</span><span class="punctuation">(</span><span class="name">Args</span><span class="operator">&amp;&amp;</span><span class="punctuation">...</span> <span class="name">args</span><span class="punctuation">);</span>

  <span class="keyword type">void</span> <span class="name function">operator</span><span class="punctuation">()(</span><span class="name">pointer</span> <span class="name">p</span><span class="punctuation">);</span>

  <span class="name">allocator_type</span><span class="operator">&amp;</span> <span class="name">get_allocator</span><span class="punctuation">();</span>
  <span class="keyword">const</span> <span class="name">allocator_type</span><span class="operator">&amp;</span> <span class="name">get_allocator</span><span class="punctuation">()</span> <span class="keyword">const</span><span class="punctuation">;</span>

<span class="keyword">private</span><span class="operator">:</span>
  <span class="name">allocator_type</span> <span class="name">alloc</span><span class="punctuation">;</span> <span class="comment single">// for exposition only
</span><span class="punctuation">};</span>

<span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">class</span> <span class="name class">T</span><span class="punctuation">,</span> <span class="keyword">class</span> <span class="name class">Alloc</span><span class="operator">&gt;</span>
<span class="keyword">class</span> <span class="name class">allocator_delete</span><span class="operator">&lt;</span><span class="name">T</span><span class="punctuation">,</span> <span class="name">Alloc</span><span class="operator">&amp;&gt;</span> <span class="punctuation">{</span>
<span class="keyword">public</span><span class="operator">:</span>
  <span class="keyword">using</span> <span class="name">allocator_type</span> <span class="operator">=</span> <span class="name">remove_cv_t</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="operator">&gt;</span><span class="punctuation">;</span>
  <span class="keyword">using</span> <span class="name">pointer</span> <span class="operator">=</span> <span class="keyword">typename</span> <span class="name">allocator_traits</span><span class="operator">&lt;</span><span class="name">allocator_type</span><span class="operator">&gt;::</span><span class="name">pointer</span><span class="punctuation">;</span>

  <span class="name">allocator_delete</span><span class="punctuation">(</span><span class="name">Alloc</span><span class="operator">&amp;</span> <span class="name">alloc</span><span class="punctuation">);</span>
  <span class="name">allocator_delete</span><span class="punctuation">(</span><span class="name">reference_wrapper</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="operator">&gt;</span> <span class="name">alloc</span><span class="punctuation">);</span>

  <span class="keyword type">void</span> <span class="name function">operator</span><span class="punctuation">()(</span><span class="name">pointer</span> <span class="name">p</span><span class="punctuation">);</span>

  <span class="name">Alloc</span><span class="operator">&amp;</span> <span class="name">get_allocator</span><span class="punctuation">()</span> <span class="keyword">const</span><span class="punctuation">;</span>

<span class="keyword">private</span><span class="operator">:</span>
  <span class="name">reference_wrapper</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="operator">&gt;</span> <span class="name">alloc</span><span class="punctuation">;</span> <span class="comment single">// for exposition only
</span><span class="punctuation">};</span>

<span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">class</span> <span class="name class">T</span><span class="punctuation">,</span> <span class="keyword">class</span> <span class="name class">Alloc</span><span class="operator">&gt;</span>
  <span class="name">allocator_delete</span><span class="operator">&lt;</span><span class="name">T</span><span class="punctuation">,</span> <span class="keyword">typename</span> <span class="name">allocator_traits</span><span class="operator">&lt;</span><span class="name">decay_t</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="operator">&gt;&gt;::</span><span class="keyword">template</span> <span class="name">rebind_alloc</span><span class="operator">&lt;</span><span class="name">T</span><span class="operator">&gt;&gt;</span>
    <span class="name">make_allocator_delete</span><span class="punctuation">(</span><span class="name">Alloc</span><span class="operator">&amp;&amp;</span> <span class="name">alloc</span><span class="punctuation">);</span>

<span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">class</span> <span class="name class">T</span><span class="punctuation">,</span> <span class="keyword">class</span> <span class="name class">Alloc</span><span class="operator">&gt;</span>
  <span class="name">allocator_delete</span><span class="operator">&lt;</span><span class="name">T</span><span class="punctuation">,</span> <span class="name">Alloc</span><span class="operator">&amp;&gt;</span>
    <span class="name">make_allocator_delete</span><span class="punctuation">(</span><span class="name">reference_wrapper</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="operator">&gt;</span> <span class="name">alloc</span><span class="punctuation">);</span>

<span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">class</span> <span class="name class">T</span><span class="punctuation">,</span> <span class="keyword">class</span> <span class="name class">Alloc</span><span class="punctuation">,</span> <span class="name">class</span><span class="punctuation">...</span> <span class="name">Args</span><span class="operator">&gt;</span>
  <span class="name">unique_ptr</span><span class="operator">&lt;</span><span class="name">T</span><span class="punctuation">,</span> <span class="name">allocator_delete</span><span class="operator">&lt;</span><span class="name">T</span><span class="punctuation">,</span> <span class="keyword">typename</span> <span class="name">allocator_traits</span><span class="operator">&lt;</span><span class="name">remove_cv_t</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="operator">&gt;&gt;::</span><span class="keyword">template</span> <span class="name">rebind_alloc</span><span class="operator">&lt;</span><span class="name">T</span><span class="operator">&gt;&gt;&gt;</span>
    <span class="name">allocate_unique</span><span class="punctuation">(</span><span class="keyword">const</span> <span class="name">Alloc</span><span class="operator">&amp;</span> <span class="name">alloc</span><span class="punctuation">,</span> <span class="name">Args</span><span class="operator">&amp;&amp;</span><span class="punctuation">...</span> <span class="name">args</span><span class="punctuation">);</span>

<span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">class</span> <span class="name class">T</span><span class="punctuation">,</span> <span class="keyword">class</span> <span class="name class">Alloc</span><span class="punctuation">,</span> <span class="name">class</span><span class="punctuation">...</span> <span class="name">Args</span><span class="operator">&gt;</span>
  <span class="name">unique_ptr</span><span class="operator">&lt;</span><span class="name">T</span><span class="punctuation">,</span> <span class="name">allocator_delete</span><span class="operator">&lt;</span><span class="name">T</span><span class="punctuation">,</span> <span class="name">Alloc</span><span class="operator">&amp;&gt;&gt;</span>
    <span class="name">allocate_unique</span><span class="punctuation">(</span><span class="name">reference_wrapper</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="operator">&gt;</span> <span class="name">alloc</span><span class="punctuation">,</span> <span class="name">Args</span><span class="operator">&amp;&amp;</span><span class="punctuation">...</span> <span class="name">args</span><span class="punctuation">);</span>
</pre>
</div>
<div class="section" id="allocator-delete">
<h2><a class="toc-backref" href="#id5">allocator_delete</a></h2>
<p>The standard library already provides one type intended to be used as the <tt class="docutils literal">Deleter</tt> for <tt class="docutils literal">unique_ptr</tt>, namely <tt class="docutils literal">default_delete</tt>. The proposed <tt class="docutils literal">allocator_delete</tt> is a second standard-provided deleter which does not use the <tt class="docutils literal">delete</tt> operator but instead delegates destruction and deletion to a user-provided allocator. By default it stores a copy of the allocator and delegates the necessary operations to the stored copy. A partial specialization for allocator references is provided which only stores a reference to the actual allocator instead of a copy for cases where allocators are stateful and either too big to be carried around in every <tt class="docutils literal">unique_ptr</tt> instance or expensive to copy.</p>
<p><tt class="docutils literal">allocator_delete</tt> does not perform rebinding in its call operator. It is an error to instantiate <tt class="docutils literal">allocator_delete</tt> with a type <tt class="docutils literal">Alloc</tt> not capable of deallocating objects of type <tt class="docutils literal">T</tt>. This decision was deliberately made to avoid unnecessary rebinding and copy-constructing of potentially stateful allocators for every single deletion in the call operator.</p>
</div>
<div class="section" id="make-allocator-delete">
<h2><a class="toc-backref" href="#id6">make_allocator_delete</a></h2>
<p>Because <tt class="docutils literal">allocator_delete</tt> must be instantiated only with an allocator type capable of deallocating the intended target type it cannot be naively created from an existing allocator without doing additional work. <tt class="docutils literal">make_allocator_delete()</tt> is the utility that hides this rebinding business from users and always returns an <tt class="docutils literal">allocator_delete</tt> type with an allocator capable of deallocating objects of type <tt class="docutils literal">T</tt>.</p>
<p>The overload taking a <tt class="docutils literal">reference_wrapper&lt;Alloc&gt;</tt> results in an <tt class="docutils literal">allocator_delete</tt> storing only a reference to an allocator instead of a copy. Because the type of the existing allocator cannot be changed and because it would be surprising to create a copy of the allocator when the user <em>deliberately</em> specified a <tt class="docutils literal">reference_wrapper</tt>, the referenced allocator must have the same type as the rebound allocator for type <tt class="docutils literal">T</tt>, meaning the condition <tt class="docutils literal">is_same&lt;remove_cv&lt;Alloc&gt;, <span class="pre">allocator_traits&lt;remove_cv&lt;Alloc&gt;&gt;::rebind_alloc&lt;T&gt;&gt;::value</span></tt> must be <tt class="docutils literal">true</tt>.</p>
</div>
<div class="section" id="allocate-unique">
<h2><a class="toc-backref" href="#id7">allocate_unique</a></h2>
<p>This is the main motivation of this proposal. The above are required to implement <tt class="docutils literal">allocate_unique()</tt> but are useful enough on their own outside the scope of <tt class="docutils literal">allocate_unique()</tt> and are therefore proposed as well.</p>
<p>The <tt class="docutils literal">allocate_unique()</tt> function is not overly big but tricky enough to implement that a naive approach might be incorrect. Below is an implementation that, to the author's knowledge, is correct and exception safe. Achieving exception safety with the two-phase creation required with the allocator interface is a common oversight.</p>
<pre class="code c++ literal-block">
<span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">class</span> <span class="name class">T</span><span class="punctuation">,</span> <span class="keyword">class</span> <span class="name class">Alloc</span><span class="punctuation">,</span> <span class="name">class</span><span class="punctuation">...</span> <span class="name">Args</span><span class="operator">&gt;</span>
<span class="keyword">auto</span> <span class="name">allocate_unique</span><span class="punctuation">(</span><span class="keyword">const</span> <span class="name">Alloc</span><span class="operator">&amp;</span> <span class="name">alloc</span><span class="punctuation">,</span> <span class="name">Args</span><span class="operator">&amp;&amp;</span><span class="punctuation">...</span> <span class="name">args</span><span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">using</span> <span class="name">traits</span> <span class="operator">=</span> <span class="keyword">typename</span> <span class="name">allocator_traits</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="operator">&gt;::</span><span class="keyword">template</span> <span class="name">rebind_traits</span><span class="operator">&lt;</span><span class="name">T</span><span class="operator">&gt;</span><span class="punctuation">;</span>
  <span class="keyword">auto</span> <span class="name">hold_deleter</span> <span class="operator">=</span> <span class="punctuation">[</span><span class="operator">&amp;</span><span class="name">alloc</span><span class="punctuation">]</span> <span class="punctuation">(</span><span class="keyword">auto</span> <span class="name">p</span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="name">traits</span><span class="operator">::</span><span class="name">deallocate</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">,</span> <span class="name">p</span><span class="punctuation">,</span> <span class="literal number integer">1</span><span class="punctuation">);</span>
  <span class="punctuation">};</span>
  <span class="keyword">auto</span> <span class="name">deleter</span> <span class="operator">=</span> <span class="name">make_allocator_delete</span><span class="operator">&lt;</span><span class="name">T</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">);</span>
  <span class="name">unique_ptr</span><span class="operator">&lt;</span><span class="name">T</span><span class="punctuation">,</span> <span class="keyword">decltype</span><span class="punctuation">(</span><span class="name">hold_deleter</span><span class="punctuation">)</span><span class="operator">&gt;</span> <span class="name">hold</span><span class="punctuation">(</span><span class="name">traits</span><span class="operator">::</span><span class="name">allocate</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">,</span> <span class="literal number integer">1</span><span class="punctuation">),</span> <span class="name">hold_deleter</span><span class="punctuation">);</span>
  <span class="name">traits</span><span class="operator">::</span><span class="name">construct</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">,</span> <span class="name">hold</span><span class="punctuation">.</span><span class="name">get</span><span class="punctuation">(),</span> <span class="name">forward</span><span class="operator">&lt;</span><span class="name">Args</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">args</span><span class="punctuation">)...);</span>
  <span class="keyword">return</span> <span class="name">unique_ptr</span><span class="operator">&lt;</span><span class="name">T</span><span class="punctuation">,</span> <span class="keyword">decltype</span><span class="punctuation">(</span><span class="name">deleter</span><span class="punctuation">)</span><span class="operator">&gt;</span><span class="punctuation">{</span><span class="name">hold</span><span class="punctuation">.</span><span class="name">release</span><span class="punctuation">(),</span> <span class="name">move</span><span class="punctuation">(</span><span class="name">deleter</span><span class="punctuation">)};</span>
<span class="punctuation">}</span>
</pre>
<p>Implementations very similar to the above can be found in numerous libraries and standard implementations. It is a pattern of boilerplate that is repeated frequently enough that it should be included in the standard. Often the intermediary use of a RAII wrapper around the <tt class="docutils literal">allocate</tt>-<tt class="docutils literal">deallocate</tt> pair is forgotten thus resulting in memory leaks if the constructor of <tt class="docutils literal">T</tt> throws. This is a trap people should not have to worry about in the first place.</p>
</div>
</div>
<div class="section" id="applications-outside-of-allocate-shared">
<h1><a class="toc-backref" href="#id8">Applications Outside of allocate_shared</a></h1>
<p><tt class="docutils literal">allocator_delete</tt> and <tt class="docutils literal">make_allocator_delete()</tt> are technically not required to be made available in the standard library's public interface as they can be easily marked as <em>implementation-defined</em> in the return type of <tt class="docutils literal">allocate_shared()</tt> as is currently done for the return type of <tt class="docutils literal">bind()</tt>. However their utility shows itself even in other applications for which some examples are given here to convince the reader of their usefulness.</p>
<div class="section" id="node-based-containers">
<h2><a class="toc-backref" href="#id9">Node-Based Containers</a></h2>
<p>Node-based containers like <tt class="docutils literal">map</tt> or <tt class="docutils literal">list</tt> do typically not store a <tt class="docutils literal">unique_ptr</tt> referencing each and every node. That would store <tt class="docutils literal">n</tt> copies of the deleter which would each have to either copy the allocator for every node or store a reference to the allocator to utilize automatic cleanup. Both are unnecessarily wasteful. The latter establishes a <em>back reference</em> from the node to the container, meaning the container becomes expensive to move as all the back references have to be updated. Instead these containers typically manually allocate/deallocate each node, store them as raw pointers, and because the type of a node is virtually never the same type as the payload, rebinding the allocator for the node type is necessary as well. Then for actually allocating each node a procedure similar to the above is performed, followed later by the manual deletion.</p>
<p>This means in practice something like this:</p>
<pre class="code c++ literal-block">
<span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">class</span> <span class="name class">T</span><span class="punctuation">,</span> <span class="keyword">class</span> <span class="name class">Alloc</span><span class="operator">&gt;</span>
<span class="keyword">class</span> <span class="name class">list</span> <span class="punctuation">{</span>
  <span class="keyword">struct</span> <span class="name">node</span> <span class="punctuation">{</span>
    <span class="name">node</span><span class="operator">*</span> <span class="name">next</span><span class="punctuation">;</span>
    <span class="name">T</span> <span class="name">payload</span><span class="punctuation">;</span>
    <span class="punctuation">...</span>
  <span class="punctuation">}</span>
  <span class="keyword">using</span> <span class="name">node_allocator</span> <span class="operator">=</span> <span class="keyword">typename</span> <span class="name">allocator_traits</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="operator">&gt;::</span><span class="keyword">template</span> <span class="name">rebind_alloc</span><span class="operator">&lt;</span><span class="name">node</span><span class="operator">&gt;</span><span class="punctuation">;</span>
  <span class="keyword">using</span> <span class="name">traits</span> <span class="operator">=</span> <span class="name">allocator_traits</span><span class="operator">&lt;</span><span class="name">node_allocator</span><span class="operator">&gt;</span><span class="punctuation">;</span>
  <span class="name">node_allocator</span> <span class="name">alloc</span><span class="punctuation">;</span>

  <span class="punctuation">...</span>

<span class="keyword">public</span><span class="operator">:</span>
  <span class="keyword type">void</span> <span class="name">push_back</span><span class="punctuation">(</span><span class="name">T</span> <span class="name">x</span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">auto</span> <span class="name">hold_deleter</span> <span class="operator">=</span> <span class="punctuation">[</span><span class="operator">&amp;</span><span class="name">alloc</span><span class="punctuation">]</span> <span class="punctuation">(</span><span class="keyword">auto</span> <span class="name">p</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      <span class="name">traits</span><span class="operator">::</span><span class="name">deallocate</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">,</span> <span class="name">p</span><span class="punctuation">,</span> <span class="literal number integer">1</span><span class="punctuation">);</span>
    <span class="punctuation">};</span>
    <span class="name">unique_ptr</span><span class="operator">&lt;</span><span class="name">node</span><span class="punctuation">,</span> <span class="keyword">decltype</span><span class="punctuation">(</span><span class="name">hold_deleter</span><span class="punctuation">)</span><span class="operator">&gt;</span> <span class="name">hold</span><span class="punctuation">(</span><span class="name">traits</span><span class="operator">::</span><span class="name">allocate</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">,</span> <span class="literal number integer">1</span><span class="punctuation">),</span> <span class="name">hold_deleter</span><span class="punctuation">);</span>
    <span class="name">traits</span><span class="operator">::</span><span class="name">construct</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">,</span> <span class="name">hold</span><span class="punctuation">.</span><span class="name">get</span><span class="punctuation">(),</span> <span class="punctuation">...);</span>
    <span class="name">append_node_to_list</span><span class="punctuation">(</span><span class="name">hold</span><span class="punctuation">.</span><span class="name">release</span><span class="punctuation">());</span> <span class="comment single">// noexcept
</span>  <span class="punctuation">}</span>

  <span class="operator">~</span><span class="name">list</span><span class="punctuation">()</span> <span class="punctuation">{</span>
    <span class="keyword">for</span><span class="punctuation">(</span><span class="keyword">auto</span><span class="operator">*</span> <span class="name label">node</span> <span class="punctuation">:</span> <span class="name">nodes</span><span class="punctuation">())</span> <span class="punctuation">{</span>
      <span class="name">traits</span><span class="operator">::</span><span class="name">destroy</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">,</span> <span class="name">node</span><span class="punctuation">);</span>
      <span class="name">traits</span><span class="operator">::</span><span class="name">deallocate</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">,</span> <span class="name">node</span><span class="punctuation">,</span> <span class="literal number integer">1</span><span class="punctuation">);</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">};</span>
</pre>
<p>Compare this to using the utilities proposed in this paper:</p>
<pre class="code c++ literal-block">
<span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">class</span> <span class="name class">T</span><span class="punctuation">,</span> <span class="keyword">class</span> <span class="name class">Alloc</span><span class="operator">&gt;</span>
<span class="keyword">class</span> <span class="name class">list</span> <span class="punctuation">{</span>
  <span class="keyword">struct</span> <span class="name">node</span> <span class="punctuation">{</span>
    <span class="name">node</span><span class="operator">*</span> <span class="name">next</span><span class="punctuation">;</span>
    <span class="name">T</span> <span class="name">payload</span><span class="punctuation">;</span>
    <span class="punctuation">...</span>
  <span class="punctuation">}</span>
  <span class="keyword">using</span> <span class="name">node_allocator</span> <span class="operator">=</span> <span class="keyword">typename</span> <span class="name">allocator_traits</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="operator">&gt;::</span><span class="keyword">template</span> <span class="name">rebind_alloc</span><span class="operator">&lt;</span><span class="name">node</span><span class="operator">&gt;</span><span class="punctuation">;</span>
  <span class="name">node_allocator</span> <span class="name">alloc</span><span class="punctuation">;</span>

  <span class="punctuation">...</span>

<span class="keyword">public</span><span class="operator">:</span>
  <span class="keyword type">void</span> <span class="name">push_back</span><span class="punctuation">(</span><span class="name">T</span> <span class="name">x</span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">auto</span> <span class="name">p</span> <span class="operator">=</span> <span class="name">allocate_unique</span><span class="operator">&lt;</span><span class="name">node</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">ref</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">),</span> <span class="punctuation">...);</span>
    <span class="name">append_node_to_list</span><span class="punctuation">(</span><span class="name">p</span><span class="punctuation">.</span><span class="name">release</span><span class="punctuation">());</span> <span class="comment single">// noexcept
</span>  <span class="punctuation">}</span>

  <span class="operator">~</span><span class="name">list</span><span class="punctuation">()</span> <span class="punctuation">{</span>
    <span class="keyword">auto</span> <span class="name">del</span> <span class="operator">=</span> <span class="name">make_allocator_deleter</span><span class="operator">&lt;</span><span class="name">node</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">ref</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">));</span>
    <span class="keyword">for</span><span class="punctuation">(</span><span class="keyword">auto</span><span class="operator">*</span> <span class="name label">node</span> <span class="punctuation">:</span> <span class="name">nodes</span><span class="punctuation">())</span> <span class="punctuation">{</span>
      <span class="name">del</span><span class="punctuation">(</span><span class="name">node</span><span class="punctuation">);</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">};</span>
</pre>
<p>It may not seem like much but the parts that were replaced in the second snippet were the most error-prone. It has much less fiddling around with <tt class="docutils literal">allocator_traits</tt> and one did not have to bother themselves with the nature of two-phase initialization and teardown of objects imposed by the allocator interface.</p>
</div>
<div class="section" id="type-erasure">
<h2><a class="toc-backref" href="#id10">Type Erasure</a></h2>
<p>Containers like <tt class="docutils literal">function</tt> or <tt class="docutils literal">shared_ptr</tt> employ a technique called <em>type erasure</em> where the exact type of the stored object is not visible in the container's type signature. Implementations often rely on using an internal abstract base class from which concrete class templates are derived. If the container has support for user-provided allocators then the allocator has to be stored somewhere as well. But because the type of the allocator is not part of the container's type signature it, too, must be erased. This means both the payload <em>and</em> the actual allocator are part of the internal object, often simply combined into a <tt class="docutils literal">tuple&lt;Alloc, T&gt;</tt>.</p>
<p>Below is an excerpt showing how such type erasure is frequently implemented:</p>
<pre class="code c++ literal-block">
<span class="keyword">class</span> <span class="name class">any</span> <span class="punctuation">{</span>
  <span class="keyword">struct</span> <span class="name">base</span> <span class="punctuation">{</span>
    <span class="keyword">virtual</span> <span class="keyword type">void</span> <span class="name">destroy</span><span class="punctuation">()</span> <span class="keyword">noexcept</span> <span class="operator">=</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
    <span class="keyword">virtual</span> <span class="keyword type">void</span> <span class="name function">do_something</span><span class="punctuation">()</span> <span class="operator">=</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
  <span class="keyword">protected</span><span class="operator">:</span>
    <span class="operator">~</span><span class="name">base</span><span class="punctuation">()</span> <span class="operator">=</span> <span class="keyword">default</span><span class="punctuation">;</span>
  <span class="punctuation">}</span>

  <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">class</span> <span class="name class">Alloc</span><span class="punctuation">,</span> <span class="keyword">class</span> <span class="name class">T</span><span class="operator">&gt;</span>
  <span class="keyword">struct</span> <span class="name label">derived</span> <span class="punctuation">:</span> <span class="name">base</span> <span class="punctuation">{</span>
    <span class="name">derived</span><span class="punctuation">(</span><span class="keyword">const</span> <span class="name">Alloc</span><span class="operator">&amp;</span> <span class="name">alloc</span><span class="punctuation">,</span> <span class="name">T</span> <span class="name">x</span><span class="punctuation">);</span>
    <span class="keyword type">void</span> <span class="name function">destroy</span><span class="punctuation">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> <span class="punctuation">{</span>
      <span class="keyword">using</span> <span class="name">rebind</span> <span class="operator">=</span> <span class="keyword">typename</span> <span class="name">allocator_traits</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="operator">&gt;::</span><span class="keyword">template</span> <span class="name">rebind_alloc</span><span class="operator">&lt;</span><span class="name">derived</span><span class="operator">&gt;</span><span class="punctuation">;</span> <span class="comment single">// X
</span>      <span class="name">rebind</span> <span class="name">alloc</span><span class="punctuation">{</span><span class="name">move</span><span class="punctuation">(</span><span class="name">get</span><span class="operator">&lt;</span><span class="literal number integer">0</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">data</span><span class="punctuation">))};</span>                                                <span class="comment single">// X
</span>      <span class="keyword">auto</span><span class="operator">*</span> <span class="name">p</span> <span class="operator">=</span> <span class="keyword">this</span><span class="punctuation">;</span>                                                                  <span class="comment single">// X &lt;- danger
</span>      <span class="name">allocator_traits</span><span class="operator">&lt;</span><span class="name">rebind</span><span class="operator">&gt;::</span><span class="name">destroy</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">,</span> <span class="name">p</span><span class="punctuation">);</span>                                     <span class="comment single">// X
</span>      <span class="name">allocator_traits</span><span class="operator">&lt;</span><span class="name">rebind</span><span class="operator">&gt;::</span><span class="name">deallocate</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">,</span> <span class="name">p</span><span class="punctuation">,</span> <span class="literal number integer">1</span><span class="punctuation">);</span>                               <span class="comment single">// X
</span>    <span class="punctuation">}</span>
    <span class="keyword type">void</span> <span class="name function">do_something</span><span class="punctuation">()</span> <span class="keyword">override</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
    <span class="name">tuple</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="punctuation">,</span> <span class="name">T</span><span class="operator">&gt;</span> <span class="name">data</span><span class="punctuation">;</span>
  <span class="punctuation">};</span>

  <span class="name">base</span><span class="operator">*</span> <span class="name">value</span><span class="punctuation">;</span>

<span class="keyword">public</span><span class="operator">:</span>
  <span class="punctuation">...</span>

  <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">class</span> <span class="name class">Alloc</span><span class="punctuation">,</span> <span class="keyword">class</span> <span class="name class">T</span><span class="operator">&gt;</span>
  <span class="keyword type">void</span> <span class="name">assign</span><span class="punctuation">(</span><span class="keyword">const</span> <span class="name">Alloc</span><span class="operator">&amp;</span> <span class="name">alloc</span><span class="punctuation">,</span> <span class="name">T</span> <span class="name">x</span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">using</span> <span class="name">node</span> <span class="operator">=</span> <span class="name">derived</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="punctuation">,</span> <span class="name">T</span><span class="operator">&gt;</span><span class="punctuation">;</span>
    <span class="keyword">using</span> <span class="name">rebind</span> <span class="operator">=</span> <span class="keyword">typename</span> <span class="name">allocator_traits</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="operator">&gt;::</span><span class="keyword">template</span> <span class="name">rebind_alloc</span><span class="operator">&lt;</span><span class="name">node</span><span class="operator">&gt;</span><span class="punctuation">;</span>                 <span class="comment single">// X
</span>    <span class="keyword">using</span> <span class="name">traits</span> <span class="operator">=</span> <span class="name">allocator_traits</span><span class="operator">&lt;</span><span class="name">rebind</span><span class="operator">&gt;</span><span class="punctuation">;</span>                                                      <span class="comment single">// X
</span>    <span class="keyword">auto</span> <span class="name">node_alloc</span> <span class="operator">=</span> <span class="name">rebind</span><span class="punctuation">{</span><span class="name">alloc</span><span class="punctuation">};</span>                                                              <span class="comment single">// X
</span>    <span class="keyword">auto</span> <span class="name">hold_deleter</span> <span class="operator">=</span> <span class="punctuation">[</span><span class="operator">&amp;</span><span class="name">node_alloc</span><span class="punctuation">]</span> <span class="punctuation">(</span><span class="keyword">auto</span> <span class="name">p</span><span class="punctuation">)</span> <span class="punctuation">{</span>                                                  <span class="comment single">// X
</span>      <span class="name">traits</span><span class="operator">::</span><span class="name">deallocate</span><span class="punctuation">(</span><span class="name">node_alloc</span><span class="punctuation">,</span> <span class="name">p</span><span class="punctuation">,</span> <span class="literal number integer">1</span><span class="punctuation">);</span>                                                       <span class="comment single">// X
</span>    <span class="punctuation">};</span>                                                                                            <span class="comment single">// X
</span>    <span class="name">unique_ptr</span><span class="operator">&lt;</span><span class="name">node</span><span class="punctuation">,</span> <span class="keyword">decltype</span><span class="punctuation">(</span><span class="name">hold_deleter</span><span class="punctuation">)</span><span class="operator">&gt;</span> <span class="name">hold</span><span class="punctuation">(</span><span class="name">traits</span><span class="operator">::</span><span class="name">allocate</span><span class="punctuation">(</span><span class="name">node_alloc</span><span class="punctuation">,</span> <span class="literal number integer">1</span><span class="punctuation">),</span> <span class="name">hold_deleter</span><span class="punctuation">);</span> <span class="comment single">// X
</span>    <span class="name">traits</span><span class="operator">::</span><span class="name">construct</span><span class="punctuation">(</span><span class="name">node_alloc</span><span class="punctuation">,</span> <span class="name">hold</span><span class="punctuation">.</span><span class="name">get</span><span class="punctuation">(),</span> <span class="name">alloc</span><span class="punctuation">,</span> <span class="name">move</span><span class="punctuation">(</span><span class="name">x</span><span class="punctuation">));</span>                                    <span class="comment single">// X
</span>    <span class="keyword">if</span><span class="punctuation">(</span><span class="name">value</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      <span class="name">value</span><span class="operator">-&gt;</span><span class="name">destroy</span><span class="punctuation">();</span>
    <span class="punctuation">}</span>
    <span class="name">value</span> <span class="operator">=</span> <span class="name">hold</span><span class="punctuation">.</span><span class="name">release</span><span class="punctuation">();</span>
  <span class="punctuation">}</span>
  <span class="operator">~</span><span class="name">any</span> <span class="punctuation">{</span>
    <span class="keyword">if</span><span class="punctuation">(</span><span class="name">value</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      <span class="name">value</span><span class="operator">-&gt;</span><span class="name">destroy</span><span class="punctuation">();</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">};</span>
</pre>
<p>About half the functional code in this example (marked with <tt class="docutils literal">X</tt>) deals with nothing else but rebinding allocators and doing the allocator dance. It also contains subtle traps. Note the line marked with <strong>danger</strong>. Were one to not make a copy of <tt class="docutils literal">this</tt> but pass it as argument to <tt class="docutils literal">destroy()</tt> and <tt class="docutils literal">deallocate()</tt> then accessing <tt class="docutils literal">this</tt> after the call to <tt class="docutils literal">destroy()</tt> (which calls the destructor) is undefined. The above can be significantly simplified with the proper tools:</p>
<pre class="code c++ literal-block">
<span class="keyword">class</span> <span class="name class">any</span> <span class="punctuation">{</span>
  <span class="keyword">struct</span> <span class="name">base</span> <span class="punctuation">{</span>
    <span class="keyword">virtual</span> <span class="keyword type">void</span> <span class="name">destroy</span><span class="punctuation">()</span> <span class="keyword">noexcept</span> <span class="operator">=</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
    <span class="keyword">virtual</span> <span class="keyword type">void</span> <span class="name function">do_something</span><span class="punctuation">()</span> <span class="operator">=</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
  <span class="keyword">protected</span><span class="operator">:</span>
    <span class="operator">~</span><span class="name">base</span><span class="punctuation">()</span> <span class="operator">=</span> <span class="keyword">default</span><span class="punctuation">;</span>
  <span class="punctuation">}</span>

  <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">class</span> <span class="name class">Alloc</span><span class="punctuation">,</span> <span class="keyword">class</span> <span class="name class">T</span><span class="operator">&gt;</span>
  <span class="keyword">struct</span> <span class="name label">derived</span> <span class="punctuation">:</span> <span class="name">base</span> <span class="punctuation">{</span>
    <span class="name">derived</span><span class="punctuation">(</span><span class="keyword">const</span> <span class="name">Alloc</span><span class="operator">&amp;</span> <span class="name">alloc</span><span class="punctuation">,</span> <span class="name">T</span> <span class="name">x</span><span class="punctuation">);</span>
    <span class="keyword type">void</span> <span class="name function">destroy</span><span class="punctuation">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> <span class="punctuation">{</span>
      <span class="keyword">auto</span> <span class="name">deleter</span> <span class="operator">=</span> <span class="name">make_allocator_delete</span><span class="operator">&lt;</span><span class="name">derived</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">move</span><span class="punctuation">(</span><span class="name">get</span><span class="operator">&lt;</span><span class="literal number integer">0</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">data</span><span class="punctuation">)));</span> <span class="comment single">// X
</span>      <span class="name">deleter</span><span class="punctuation">(</span><span class="keyword">this</span><span class="punctuation">);</span>                                                     <span class="comment single">// X
</span>    <span class="punctuation">}</span>
    <span class="keyword type">void</span> <span class="name function">do_something</span><span class="punctuation">()</span> <span class="keyword">override</span> <span class="punctuation">{</span> <span class="punctuation">...</span> <span class="punctuation">}</span>
    <span class="name">tuple</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="punctuation">,</span> <span class="name">T</span><span class="operator">&gt;</span> <span class="name">data</span><span class="punctuation">;</span>
  <span class="punctuation">};</span>

  <span class="name">base</span><span class="operator">*</span> <span class="name">value</span><span class="punctuation">;</span>

<span class="keyword">public</span><span class="operator">:</span>
  <span class="punctuation">...</span>

  <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">class</span> <span class="name class">Alloc</span><span class="punctuation">,</span> <span class="keyword">class</span> <span class="name class">T</span><span class="operator">&gt;</span>
  <span class="keyword type">void</span> <span class="name">assign</span><span class="punctuation">(</span><span class="keyword">const</span> <span class="name">Alloc</span><span class="operator">&amp;</span> <span class="name">alloc</span><span class="punctuation">,</span> <span class="name">T</span> <span class="name">x</span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">using</span> <span class="name">node</span> <span class="operator">=</span> <span class="name">derived</span><span class="operator">&lt;</span><span class="name">Alloc</span><span class="punctuation">,</span> <span class="name">T</span><span class="operator">&gt;</span><span class="punctuation">;</span>
    <span class="keyword">auto</span> <span class="name">p</span> <span class="operator">=</span> <span class="name">allocate_unique</span><span class="operator">&lt;</span><span class="name">node</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">alloc</span><span class="punctuation">,</span> <span class="name">alloc</span><span class="punctuation">,</span> <span class="name">x</span><span class="punctuation">);</span> <span class="comment single">// X
</span>    <span class="keyword">if</span><span class="punctuation">(</span><span class="name">value</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      <span class="name">value</span><span class="operator">-&gt;</span><span class="name">destroy</span><span class="punctuation">();</span>
    <span class="punctuation">}</span>
    <span class="name">value</span> <span class="operator">=</span> <span class="name">p</span><span class="punctuation">.</span><span class="name">release</span><span class="punctuation">();</span>
  <span class="punctuation">}</span>
  <span class="operator">~</span><span class="name">any</span> <span class="punctuation">{</span>
    <span class="keyword">if</span><span class="punctuation">(</span><span class="name">value</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      <span class="name">value</span><span class="operator">-&gt;</span><span class="name">destroy</span><span class="punctuation">();</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">};</span>
</pre>
<p>In the altered example only <em>three lines of code</em> (marked with <tt class="docutils literal">X</tt>) deal with creation and destuction of the type erased objects with a custom allocator. Note that we pass the allocator twice to <tt class="docutils literal">allocate_unique()</tt> as the first argument is the allocator used to allocate the node (automatically rebound for us to the compatible type) and the second argument is forwarded to the allocated node to make a copy available for the <tt class="docutils literal">destroy()</tt> method.</p>
</div>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id11">Open Issues</a></h1>
<div class="section" id="allocate-unique-t">
<h2><a class="toc-backref" href="#id12">allocate_unique&lt;T[]&gt;</a></h2>
<p>The current design of <tt class="docutils literal">unique_ptr</tt> and the associated deleter means we cannot make <tt class="docutils literal">allocator_delete</tt> compatible with the array-based <tt class="docutils literal"><span class="pre">unique_ptr&lt;T[]&gt;</span></tt> specialization because there is no way to tell the deleter how many objects to delete. <tt class="docutils literal">default_delete</tt> circumvents this problem because the <tt class="docutils literal">delete[]</tt> operator knows how many elements were allocated with <tt class="docutils literal">new T[]</tt> and it combines both destruction and deallocation in one operation. In contrast the allocator interface imposes a two-phase cleanup process. Making <tt class="docutils literal">allocator_delete</tt> universally compatible with array-based <tt class="docutils literal"><span class="pre">unique_ptr&lt;T[]&gt;</span></tt> requires the addition of a second overload to the deleter's call operator with the signature <tt class="docutils literal">void(pointer p, size_t n)</tt> which <tt class="docutils literal"><span class="pre">unique_ptr&lt;T[]&gt;</span></tt> would prefer if present. This overload loops over all elements calling <tt class="docutils literal">destroy()</tt> for each and finally calls <tt class="docutils literal">deallocate()</tt> with the provided size.</p>
<p>But since that requires modifications to existing library types it is currently not proposed and therefore <tt class="docutils literal">allocate_unique()</tt> with its first template parameter being of the form <tt class="docutils literal">T[]</tt> is ill-formed.</p>
</div>
</div>
<div class="section" id="summary">
<h1><a class="toc-backref" href="#id13">Summary</a></h1>
<p>Experience shows that the mechanism abstracted behind <tt class="docutils literal">allocate_unique()</tt> is widely re-invented in many projects. Standard library implementations already have it for internal use but people still have to implement their own. As shown in this proposal doing so correctly is tricky and requires more knowledge about the interface of allocators than is usually necessary to actually do the required job. As such the barrier of entry to providing allocator support in a library is often very high as doing it properly involves careful studying of the allocator interface which many consider to be expert-level territory and prefer not to touch with a ten foot pole.</p>
<p>The provided examples show how making some utilities used to implement <tt class="docutils literal">allocate_unique()</tt> available as part of the public interface can greatly help in adding allocator support to other data structures by significantly cutting down on the required boilerplate.</p>
</div>
<div class="section" id="technical-specification">
<h1><a class="toc-backref" href="#id14">Technical Specification</a></h1>
<p>TBA</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id15">References</a></h1>
<p>TBA</p>
</div>
</div>
</body>
</html>
